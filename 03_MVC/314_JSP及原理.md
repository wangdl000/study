
## Jsp简介

JSP（Java Server Pages）是JavaWeb服务器端的动态资源,它与html页面的作用是相同的，显示数据和获取数据。  
jsp: 作为请求发起页面，例如显示表单、超链接。   
: 作为请求结束页面，例如显示数据。  
Servlet：  
作为请求中处理数据的环节。  
jsp的组成   
jsp = html + java脚本 + jsp标签(指令)
jsp中可直接使用的对象一共有9个，被称之为9大内置对象
3种java脚本： 
<%…%>：写java代码片段，(类似方法)   
<%=…%>：用于输出，用于输出一条表达式（或变量）的结果。   
<%!…%>：声明，用来创建类的成员变量和成员方法(类似与类)  
jsp注释：<%– … –%>   
当服务器把jsp编译成java文件时已经忽略了注释部分！  
jsp原理(看源码)  

jsp其实是一种特殊的Servlet  
当jsp页面第一次被访问时，服务器会把jsp编译成java文件  
然后再把java编译成.class  
然后创建该类对象  
最后调用它的service()方法  
第二次请求同一jsp时，直接调用service()方法。  
### jsp三大指令

  - **page**  

    <%@page language=”java” info=”xxx”…%>**

## pageEncoding和contentType：  
  - pageEncoding：它指定当前jsp页面的编码，只要不说谎，就不会有乱码！在服务器要把jsp编译成.java时需要使用pageEncoding!  
  - contentType：它表示添加一个响应头：Content-Type！等同与response.setContentType(“text/html;charset=utf-8”);   
如果两个属性只提供一个，那么另一个的默认值为设置那一个。 
如果两个属性都没有设置，那么默认为iso。
  - import：导包！可以出现多次  
  - errorPage和isErrorPage  
 - errorPage：当前页面如果抛出异常，那么要转发到哪一个页面，由errorPage来指定 
isErrorPage：它指定当前页面是否为处理错误的页面！当该属性为true时，这个页面会设置状态码为500！而且这个页面可以使用9大内置对象中的exception!  
<error-page>有两种使用方式：  
<error-code>和<location>子元素；  
<exception-type>和<location>子元素；  
其中<error-code>是指定响应码；  <location>指定转发的页面；<exception-type>是指定抛出的异常类型。  

    <error-page>
    <error-code>404</error-code>
    <location>/error/errorPage.jsp</location>
    </error-page>
      <error-page>
    <exception-type>java.lang.RuntimeException</exception-type>
        <location>/index.jsp</location>
      </error-page>
1
2
3
4
5
6
7
8
autoFlush和buffer 
autoFlush：指定jsp的输出流缓冲区满时，是否自动刷新！默认为true，如果为false，那么在缓冲区满时抛出异常！ 
buffer：指定缓冲区大小，默认为8kb，通常不需要修改！
isELIgnored：是否忽略el表达式，默认值为false，不忽略，即支持！
(以下了解即可)： 
language：指定当前jsp编译后的语言类型，默认值为java。 
info：信息！ 
isThreadSafe：当前的jsp是否支持并发访问！ 
session：当前页面是否支持session，如果为false，那么当前页面就没有session这个内置对象！ 
extends：让jsp生成的servlet去继承该属性指定的类！
include –> 静态包含

与RequestDispatcher的include()方法的功能相似！
<%@include%> 它是在jsp编译成java文件时完成的！他们共同生成一个java(就是一个servlet)文件，然后再生成一个class！
RequestDispatcher的include()是一个方法，包含和被包含的是两个servlet，即两个.class！他们只是把响应的内容在运行时合并了！
作用：把页面分解了，使用包含的方式组合在一起，这样一个页面中不变的部分，就是一个独立jsp，而我们只需要处理变化的页面。
taglib –> 导入标签库

两个属性： 
prefix：指定标签库在本页面中的前缀！由我们自己来起名称！ 
uri: 指定标签库的位置！ 
<%@taglib prefix=”s” uri=”/struts-tags”%> 前缀的用法<s:text>
九大内置对象

在jsp中无需声明即可直接使用的9个对象 
out（JspWriter）：等同与response.getWriter()，用来向客户端发送文本数据；
config（ServletConfig）：对应“真身”中的ServletConfig；
page（当前JSP的真身类型）：当前JSP页面的“this”，即当前对象，引用为Object类型；
pageContext（PageContext）：页面上下文对象，它是最后一个没讲的域对象；
exception（Throwable）：只有在错误页面中可以使用这个对象；
request（HttpServletRequest）：即HttpServletRequest类的对象；
response（HttpServletResponse）：即HttpServletResponse类的对象；
application（ServletContext）：即ServletContext类的对象；
session（HttpSession）：即HttpSession类的对象，不是每个JSP页面中都可以使用，如果在某个JSP页面中设置<%@page session=”false”%>，说明这个页面不能使用session。
pageContext(一个顶9个！) 
Servlet中有三大域，而JSP中有四大域！ 
ServletContext：整个应用程序 
session：整个会话(一个会话中只有一个用户) 
request：一个请求链！ 
pageContext：一个jsp页面！这个域是在当前jsp页面和当前jsp页面中使用的标签之间共享数据！ 
域对象 
代理其他域：pageContext.setAttribute(“xxx”, “XXX”, PageContext.SESSION_SCOPE); 
全域查找：pageContext.findAttribute(“xxx”);从小到大，依赖查找！ 
获取其他8个内置对象：
JSP动作标签

动作标签是由tomcat(服务器)来解释执行！而html标签由浏览器来执行！
<jsp:include> 
例如：<jsp:include page="xxx"/>，用来包含指定的页面。假如有两个jsp. 分别为a.jsp和b.jsp,他们分别编码成Servlet，然后在执行Servlet时才会执行包含过程。这也是include指令与include标签的区别。 
注意：<jsp:include page="<%=myfile%>">，这是可以的！因为include指令是在执行时才完成的包含，在执行时已经可以确定myfile这个变量的值。
该标签内部使用的是RequestDispatcher#include()方法完成的包含
<jsp:forward> 
例如：<jsp:forward page="xxx"/>，用来转发到指定页面 
例如在a.jsp中存在如下内容：<jsp:fowrad page="b.jsp"/> 
a.jsp中的内容不会显示在浏览器上，而只是显示b.jsp的内容。而且在<jsp:forwad>标签下面的内容不会被执行。
<jsp:param> 
该标签是和的子标签，用来向其他页面传递参数。
<jsp:include page="/b.jsp">
    <jsp:param value="zhangSan" name="username"/> 
</jsp:include>
1
2
3
在b.jsp中可以使用request.getParameter(“username”)来获取参数值。
javaBean

必须有public的无参的构造器
如果成员变量提供了getter/setter方法，那么称之为javabean属性。
JavaBean主要是用来通过反射操作的类！ 
因为需要通过Class的newInstance()方法来创建类的实例，所以要求类必须提供public的无参构造器
内省

内省类 –> Bean信息 –> 属性描述符 –> 属性的get/set对应的Method！ — > 反射 
通过Class对象获取BeanInfo 
BeanInfo info = Introspector.getBeanInfo(User.class);
通过BeanInfo获取所有属性描述符对象 
PropertyDescriptor[] pds = info.getPropertyDescriptors();
PropertyDescriptor： 
String name getName()：获取当前属性名称
Method getReadMethod()：获取get方法反射对象
Method getWriteMethod()：获取set方法反射对象
jar包 commons-beanutils.jar、commons-logging.jar
通过反射设置Javabean 
Class<User> clazz = User.class; 
Object user = clazz.newInstance(); 
BeanUtils.setProperty(user, “username”, “admin”); 
BeanUtils.setProperty(user, “password”, “admin123”);
获取属性值 
String username = BeanUtils.getProperty(user, “username”);
把Map数据封装到JavaBean对象中
Map<String,String> map = new HashMap<String,String>();
map.put("username", "admin");
map.put("password", "admin123");
1
2
3
User user = new User(); 
BeanUtils.populate(user, map);
要求：map的key名称必须与User类的属性名称相同。不要无法赋值！
JSP中与JavaBean相关的标签

<jsp:useBean>
<jsp:setProperty>
<jsp:getProperty>
<jsp:useBean id="user1" class="cn.domain.User" />
1
查看page域中是否存在user1这个域属性，如果存在，那么直接获取。 
如果不存在，那么创建之！ 
等同与： 
User user1 = pageContext.getAttribute(“user1”); 
if(user1 == null) { 
user1 = new User();//创建user1对象 
pageContext.setAttribute(“user1”, user1);//保存到page域 
}
可以通过scope属性来指定操作 

设置属性值:
<jsp:setProperty property="username" name="user1" value="admin"/>
1
name：指定名为user1的JavaBean
property：指定要设置的属性名称
value：指定要设置的属性值 
等同与 
User user1 = (User)pageContext.getAttribute(“user1”); 
user1.setUsername(“admin”);
**<jsp:getProperty>**
1
获取属性值

<jsp:getProperty property="username" name="user1"/>
1
输出user1这个javaBean的username属性值

等同与 
User user1 = (User)pageContext.getAttribute(“user1”); 
out.print(user1.getUsername());

EL表达式


EL：Expression Language，它是可以在JSP页面中直接使用的语言！ 
JSP页面也可以忽略EL：<@page isELIgnored=”true”%> 
EL用来代替<%=…%>
EL 11个内置对象 
EL可以输出的东西都在11个内置对象中！11个内置对象，其中10个是Map！pageContext不是map，它就是PageContext类型，1一个顶九个
${pageScope.xxx}、
${requestScope.xxx}、
${sessionScope.xxx}、
${applicationScope.xxx}
param：对应参数，它是一个Map，其中key参数名，value是参数值，适用于单值的参数。
paramValues：对应参数，它是一个Map，其中key参数名，value是多个参数值，适用于多值的参数。
header：对应请求头，它是一个Map，其中key表示头名称，value是单个头值，适用于单值请求头
headerValues：对应请求头，它是一个Map，其中key表示头名称，value是多个头值，适用于多值请求头
initParam：获取<context-param>内的参数！
cookie：Map<String,Cookie>类型，其中key是cookie的name，value是cookie对象。 ${cookie.username.value}
pageContext：它是PageContext类型！${pageContext.request.contextPath}

EL操作四大域的内置对象：它们是Map类型 
pageScope 
requestScope 
sessionScope 
applicationScope
${pageScope.user}：输出pageContext.getAttribute("user")
${requestScope.user}：输出request.getAttribute("user");
${sessionScope.user}：输出session.getAttribute("user");
${applicationScope.user}：输出application.getAttribute("user");
1
2
3
4
${user} 
依次在pageScope、requestScope、sessionScope、applicationScope中查找user 
如果查找到，那么立刻停止查找。
操作JavaBean 
<% 
User user = new User(); 
user.setUsername(“zhangSan”); 
user.setPassword(“123”); 
pageContext.setAttribute(“user”, user); 
%>
${pageScope.user.username}
${pageScope.user.password}
1
2
操作List 
<% 
User user = new User(); 
user.setUsername(“zhangSan”); 
user.setPassword(“123”); 
List list = new ArrayList(); 
list.add(user); 
pageContext.setAttribute(“list”, list); 
%>
${pageScope.list[0].username}
${pageScope.list[0].password}
1
2
操作Map 
<% 
User user = new User(); 
user.setUsername(“zhangSan”); 
user.setPassword(“123”); 
Map map = new HashMap(); 
map.put(“u1”, user); 
pageContext.setAttribute(“map”, map); 
%>
${pageScope.map['u1'].username}
${pageScope.map['u1'].password}

${pageScope.map.u1.username}
${pageScope.map.u1.password}
1
2
3
4
5
EL操作参数内置对象：Map类型

param：Map<String,String>
paramValues：Map<String,String[]>
${param.username}：request.getParameter("username")
${paramValues.hobby}：request.getParameterValues("hobby");
1
2
3
4
EL操作请求头内置对象：Map类型

header：Map<String,String>
headerValues：Map<String,String[]>

${header.UserAgent}
${headerValues.UserAgener[0]
1
2
3
4
5
与Cookie相关的内置对象：Map类型
cookie：Map<String,Cookie>，其中key是Cookie的名称，而值是Cookie对象
1
${cookie.jsessionid.value}：获取sessionid
1
pageContext内置对象：PageContext类型
${pageContext.request}，等同pageContext.getRequest()
${pageContext.session}，等同pageContext.getSession()

${pageContext.request.contextpath}，获取项目名
${pageContext.session.id}，获取sessionId
1
2
3
4
5
EL中最重要的就是操作四大域！ 
使用EL函数库需要在JSP页面中导入标签库： 
导入标签库：<%@ tablib prefix=”fn” uri=”http://java.sun.com/jsp/jstl/functions”%> 
String toUpperCase(String input)：把参数转换成大写 
String toLowerCase(String input)：把参数转换成小写 
int indexOf(String input, String substring)：从大串，输出小串的位置！ 
boolean contains(String input, String substring)：查看大串中是否包含小串 
boolean containsIgnoreCase(String input, String substring)：忽略大小写的，是否包含 
boolean startsWith(String input, String substring)：是否以小串为前缀 
boolean endsWith(String input, String substring)：是否以小串为后缀 
String substring(String input, int beginIndex, int endIndex)：截取子串 
String substringAfter(String input, String substring)：获取大串中，小串所在位置后面的字符串 
substringBefore(String input, String substring)：获取大串中，小串所在位置前面的字符串 
String escapeXml(String input)：把input中“<”、”>”、”&”、”’”、”“”，进行转义 
String trim(String input)：去除前后空格 
String replace(String input, String substringBefore, String substringAfter)：替换 
String[] split(String input, String delimiters)：分割字符串，得到字符串数组
int length(Object obj)：可以获取字符串、数组、各种集合的长度！ 
String join(String array[], String separator)：联合字符串数组！
<%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/function"%>

<%@taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %>
…
String[] strs = {"a", "b","c"};
List list = new ArrayList();
list.add("a");
pageContext.setAttribute("arr", strs);
pageContext.setAttribute("list", list);
%>
${fn:length(arr) }<br/><!--3-->
${fn:length(list) }<br/><!--1-->
${fn:toLowerCase("Hello") }<br/> <!-- hello -->
${fn:toUpperCase("Hello") }<br/> <!-- HELLO -->
${fn:contains("abc", "a")}<br/><!-- true -->
${fn:containsIgnoreCase("abc", "Ab")}<br/><!-- true -->
${fn:contains(arr, "a")}<br/><!-- true -->
${fn:containsIgnoreCase(list, "A")}<br/><!-- true -->
${fn:endsWith("Hello.java", ".java")}<br/><!-- true -->
${fn:startsWith("Hello.java", "Hell")}<br/><!-- true -->
${fn:indexOf("Hello-World", "-")}<br/><!-- 5 -->
${fn:join(arr, ";")}<br/><!-- a;b;c -->
${fn:replace("Hello-World", "-", "+")}<br/><!-- Hello+World -->
${fn:join(fn:split("a;b;c;", ";"), "-")}<br/><!-- a-b-c -->

${fn:substring("0123456789", 6, 9)}<br/><!-- 678 -->
${fn:substring("0123456789", 5, -1)}<br/><!-- 56789 -->
${fn:substringAfter("Hello-World", "-")}<br/><!-- World -->
${fn:substringBefore("Hello-World", "-")}<br/><!-- Hello -->
${fn:trim("     a b c     ")}<br/><!-- a b c -->
${fn:escapeXml("<html></html>")}<br/> <!-- <html></html> -->
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
自定义函数库

写一个java类，类中可以定义0~N个方法，但必须是static，而且有返回值的！
在WEB-INF目录下创建一个tld文件
  <function>
    <name>fun</name>
    <function-class>haha.fn.MyFunction</function-class>
    <function-signature>java.lang.String fun()</function-signature>
  </function>
1
2
3
4
5
在jsp页面中导入标签库 
<%@ taglib prefix=”it” uri=”/WEB-INF/tlds/haha.tld” %>
在jsp页面中使用自定义的函数：${it:fun() }
JSTL

JSTL是apache对EL表达式的扩展
jstl标签库

core：核心标签库，
fmt：格式化标签库
sql：数据库标签库，过时；
xml：xml标签库，过时。
<c:core>

<c:out value=”aaa”/> 输出字符串aaa
<c:out value="${aaa}”/> 输出域属性aaa，其中与${aaa}相同
<c:out value="${aaa}” default=”xxx”/>如果${aaa}不存在，那么输出xxx字符串
<c:out value="${aaa}" escapeXml=”true”/>如果${aaa}中包含特殊字符，那么转义它。这可以防止javascript攻击
<c:set>

<c:set var=”a” value=”hello”/> 创建名为a,值为hello的域属性，范围：page
<c:set var=”a” value=”hello” scope=”session”/> 范围为session(page、request、session、application)
<C:remove>

<c:remove var=”a”/> 删除名为a的域属性
<c:remove var=”a” scope=”page”/> 删除page域中名为a的域属性
<C:url>

<c:url value=”/AServlet”/> 输出URL：/项目名/AServlet
<c:url value=”/AServlet” var=”url” scope=”page”/> 把生成的url保存到page域中，而不会输出
子标签：<c:param>，用来给url后面添加参数，例如：
    <c:url value="/index.jsp">
      <c:param name="username" value="张三"/>  <!--可以对参数进行url编码！！-->
    </c:url>
1
2
3
结果为：/day13_1/index.jsp?username=%ED%2C%3F%ED%2C%3F
1
* var：指定变量名，一旦添加了这个属性，那么url标签就不会再输出到页面，而是把生成url保存到域中。 
* scope：它与var一起使用，用来保存url。

<C:if>

*<c:if test=”${条件}”> 当条件为true时执行标签体内容 
hello 
＜c:choose>

<c:set var="score" value="${param.score }"/>
<c:choose>
    <c:when test="${score > 100 || score < 0}">错误的分数：${score }</c:when>[if]
    <c:when test="${score >= 90 }">A级</c:when>
    <c:when test="${score >= 80 }">B级</c:when>
    <c:when test="${score >= 70 }">C级</c:when>
    <c:when test="${score >= 60 }">D级</c:when>
    <c:otherwise>E级</c:otherwise>[else]
</c:choose>
1
2
3
4
5
6
7
8
9
<c:forEach>

<c:forEach var="i" begin="1" end="10">
    ${i}
  </c:forEach>
1
2
3
属性： 
* var：循环变量 
* begin：设置循环变量从几开始。 
* end：设置循环变量到几结束。 
* step：设置步长！等同与java中的i++，或i+=2。step默认为1

遍历集合或数组方式：
<%
String[] names = {"zhangSan", "liSi", "wangWu", "zhaoLiu"};
pageContext.setAttribute("ns", names);
%>
<c:forEach var="item" items="${ns }">
    <c:out value="name: ${item }"/><br/>
</c:forEach>
1
2
3
4
5
6
7
遍历List
<%
    List<String> names = new ArrayList<String>();
    names.add("zhangSan");
    names.add("liSi");
    pageContext.setAttribute("ns", names);
%>
<c:forEach var="item" items="${ns }">
    <c:out value="name: ${item }"/><br/>
</c:forEach>
1
2
3
4
5
6
7
8
9
遍历Map
<%
    Map<String,String> stu = new LinkedHashMap<String,String>();
    stu.put("number", "N_1001");
    stu.put("name", "zhangSan");
    pageContext.setAttribute("stu", stu);
%>
<c:forEach var="item" items="${stu }">
    <c:out value="${item.key }: ${item.value }"/><br/>
</c:forEach>
1
2
3
4
5
6
7
8
9
循环状态
循环状态变量有如下属性： 
* count：循环元素的个数 
* index：循环元素的下标 
* first：是否为第一个元素 
* last：是否为最后一个元素 
* current：当前元素
<c:forEach items="${list }" var="ele" varStatus="vs">
    ${vs.index} ${vs.count } ${vs.first } ${vs.last } ${vs.current }<br/>
</c:forEach>
1
2
3
fmt库

<fmt:formatDate value=”” pattern=”“> 
value：指定一个Date类型的变量 
pattern：用来指定输出的模板！例如：yyyy-MM-dd HH:mm:ss 
<fmt:formatNumber value=”${num1}” pattern=”0.00”> 
保留小数点后2位，它会四舍五入！如果不足2位，以0补位！ 
<fmt:formatNumber value=”${num1}” pattern=”#.##”> 
保留小数点后2位，它会四舍五入！如果不足2位，不补位！
自定义标签(实现SimpleTag接口，即简单标签)

步骤： 
1. 标签处理类：继承SimpleTagSupport类 
public class HelloTag extends SimpleTagSupport { 
public void doTag() throws JspException, IOException { 
this.getJspContext().getOut().write(“<p>Hello SimpleTag!</p>“) ; 
} 
}
标签描述符文件(tld) 
/WEB-INF/tlds/haha.tld
<?xml version="1.0" encoding="UTF-8"?>
<taglib version="2.0" xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xml="http://www.w3.org/XML/1998/namespace" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee 
                        http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd ">

    <tlib-version>1.0</tlib-version> 
    <short-name>haha</short-name> 
    <uri>http://www.haha.cn/tags</uri> 
    <tag> 
        <name>hello</name> <!--标签名称-->
        <tag-class>cn.haha.tag.HelloTag</tag-class> <!--标签处理类名称-->
        <body-content>empty</body-content> <!--标签体为空，即空标签-->
    </tag>
</taglib>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
jsp页面中使用自定义标签
<%@ taglib prefix="it"  uri="/WEB-INF/hello.tld"  %>
......
<it:hello/>
1
2
3
有标签体的标签

标签处理类 
public class HelloTag extends SimpleTagSupport { 
public void doTag() throws JspException, IOException { 
PageContext pc = (PageContext) this.getJspContext(); 
HttpServletRequest req = (HttpServletRequest) pc.getRequest(); 
String s = req.getParameter(“exec”); 
if(s != null && s.endsWith(“true”)) { 
// 获取标签体对象 
JspFragment body = this.getJspBody() ; 
// 执行标签体 
body.invoke (null); 
}

} 
}

tld

<tag>
        <name>hello</name>
        <tag-class>cn.itcast.tags.HelloTag</tag-class>
        <body-content>scriptless</body-content> <!--标签体内容不可以是java脚本，但可以是el、jstl等-->
    </tag>
1
2
3
4
5
不执行标签下面的页面内容

public void doTag() throws JspException, IOException {
    this.getJspContext().getOut().print("<h1>只能看到我！</h1>");
    throw new SkipPageException();
}
1
2
3
4
带有属性的标签

public class IfTag extends SimpleTagSupport { 
private boolean test;//设置属性，提供getter/setter方法 
public boolean isTest() { 
return test; 
} 
public void setTest (boolean test) { 
this.test = test; 
} 
@Override 
public void doTag() throws JspException, IOException { 
if(test) {//如果test为true，执行标签体内容 
this.getJspBody().invoke(null); 
} 
} 
}

<tag> 
    <name>if</name> 
    <tag-class>cn.haha.tag.IfTag</tag-class> 
    <body-content>scriptless</body-content>
    <!--部署属性-->
    <attribute> 
        <name>test</name> <!--属性名-->
        <required>true</required> <!--属性是否为必须的-->
        <rtexprvalue>true</rtexprvalue> <!--属性值是否可以为EL或JSTL等-->
    </attribute> 
</tag>

资料来源：  
https://blog.csdn.net/yeiweilan/article/details/69948491